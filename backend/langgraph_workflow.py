# backend/quiz_agent.py

from typing import TypedDict, List, Optional, Any
from langgraph.graph import StateGraph, END


from backend.question_parser import generate_questions_with_langchain, evaluate_quiz_format, parse_questions
from backend.rag_vector_store import get_rag_context








# Define the state of our LangGraph.
class QuizState(TypedDict):
    n: int                         # Number of questions requested
    class_name: str                # Class name for the quiz
    subject: str | List[str]       # Subject(s) for the quiz
    language: str                  # Language for the quiz
    include_rag: bool              # Flag to indicate if RAG should be used
    rag_context: Optional[str]     # Retrieved RAG context (can be None)
    raw_quiz_text: str | None      # Raw text generated by the LLM
    parsed_questions: List[dict]   # List of structured questions
    evaluation_result: bool | None # Result of the format evaluation (True/False)
    retries: int                   # Counter for regeneration attempts
    vector_store: Any | None       # FAISS vector store object





def generate_quiz_node(state: QuizState) -> QuizState:
    """
    LangGraph node to generate quiz questions.
    Conditionally retrieves RAG context and passes it to the LLM.
    """
    print("--- LangGraph Node: Generating Quiz Questions ---")
    
    
    rag_context = None
    if state["include_rag"] and state.get("vector_store"):
        # Convert list subject to string if needed
        query = state["subject"]
        if isinstance(query, list):
            query = ", ".join(query)
        rag_context = get_rag_context(query, state["vector_store"], k=2)
    
    raw_text = generate_questions_with_langchain(
        n=state["n"],
        class_name=state["class_name"],
        subject=state["subject"],
        language=state["language"],
        rag_context=rag_context
    )
    return {**state, "raw_quiz_text": raw_text, "rag_context": rag_context, "retries": state["retries"]+1}







def evaluate_quiz_node(state: QuizState) -> QuizState:
    """
    LangGraph node to evaluate the format of the raw generated quiz text.
    """
    print("--- LangGraph Node: Evaluating Quiz Format ---")
    is_valid = evaluate_quiz_format(state["raw_quiz_text"])
    # Return a new state dictionary with updates
    return {**state, "evaluation_result": is_valid}






def parse_quiz_node(state: QuizState) -> QuizState:
    """
    LangGraph node that parses the quiz.
    """
    print("--- LangGraph Node: Parsing Quiz Questions ---")
    raw_text = state["raw_quiz_text"]
    print(f"Raw text received for parsing (first 500 chars):\n{raw_text[:500]}...")
    
    parsed = parse_questions(raw_text) 
    print(f"Number of questions parsed by parse_questions: {len(parsed)}")
    
    return {**state, "parsed_questions": parsed}








def decide_to_regenerate(state: QuizState) -> str:
    """
    Conditional logic for the LangGraph.
    Decides whether to regenerate questions, end successfully, or end with failure.
    """
    if state["evaluation_result"] and state.get("parsed_questions") and len(state["parsed_questions"]) > 0:
        print("--- LangGraph Decision: Quiz Format Valid and Parsed Successfully. Ending. ---")
        return "end"
    
    if state["retries"] < 3:
        print(f"--- LangGraph Decision: Quiz Format Invalid or Parsing Failed. Retrying ({state['retries']} of 3). ---")
        return "regenerate"
    else:
        print("--- LangGraph Decision: Max retries reached. Ending with failure. ---")
        return "fail"





# --- BUILD THE LANGGRAPH ---
def build_quiz_generation_graph():
    """
    Builds and compiles the LangGraph workflow for quiz generation.
    """
    workflow = StateGraph(QuizState)

    workflow.add_node("generate", generate_quiz_node)
    workflow.add_node("evaluate", evaluate_quiz_node)
    workflow.add_node("parse", parse_quiz_node)

    workflow.set_entry_point("generate")

    workflow.add_edge("generate", "evaluate")
    workflow.add_edge("evaluate", "parse")

    workflow.add_conditional_edges(
        "parse",
        decide_to_regenerate,
        {
            "regenerate": "generate",
            "end": END,
            "fail": END
        }
    )
    return workflow.compile()






# --- FUNCTION TO RUN THE QUIZ GENERATION AGENT ---

def run_quiz_generation_agent(n, class_name, subject, language, include_rag: bool, vector_store: Optional[Any] = None):
    """
    Runs the LangGraph agent to generate, evaluate, and parse quiz questions.
    Returns the list of parsed questions or an empty list if generation fails.
    """
    app = build_quiz_generation_graph()
    initial_state = {
        "n": n,
        "class_name": class_name,
        "subject": subject,
        "language": language,
        "include_rag": include_rag,
        "rag_context": None,
        "raw_quiz_text": None,
        "parsed_questions": [],
        "evaluation_result": None,
        "retries": 0,
        "vector_store": vector_store,
    }

    # Use app.invoke() to get the final state directly
    final_state = app.invoke(initial_state)

    print(f"\n--- Full final_state returned by run_quiz_generation_agent: {final_state}\n")
    print(f"--- run_quiz_generation_agent final_state['parsed_questions']: {final_state.get('parsed_questions')}")

    # The check remains the same, but now final_state should be complete
    if final_state and isinstance(final_state.get("parsed_questions"), list):
        return final_state["parsed_questions"]
    return []
